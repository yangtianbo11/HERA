%{
/*

   This is a lexical scanner specification for the "lex" (or "flex") language.
   It can be translated into a "C++" file by running, in the project directory, the command

    flex  -t scanner-regexp.l > scanner-regexp.cpp   # remember to use "cd" to get to the right directory first


   In this first section of the lex file (between %{ and %}),
   we define C++ functions that will be used later in the actions of part 3.

*/

#include "scanner-regexp.h"

// the code generated by the flex system requires we write this:
extern "C" int yywrap()
{
 return 1;
}

%}

/* In this second section of the lex file (after the %}),
   we can define variables in terms of regular expressions.
   C-style comments (like this one) are also legal. */

digit		[0-9]
identifier	[a-zA-Z][a-z0-9_]*

/* In the third section of the lex file (after the %%),
   we can define the patterns for each token
   in terms of regular expressions and the variables above,
   and give the action (as C++ code) for each token.
   Comments are legal only inside the actions. */

%%

[ \t]		{ continue; }  /* do nothing with blank spaces */
[\n\r]		{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
\;.*		{ continue; }  /* treat comments like other blank space */

\(			{ tokenCount++; return LPAREN; }
\)			{ tokenCount++; return RPAREN; }
\+			{ tokenCount++; return PLUS; }
\-			{ tokenCount++; return MINUS; }
\*			{ tokenCount++; return TIMES; }

\=			{ tokenCount++; return EQUAL; }
\<\=			{ tokenCount++; return LESS_OR_EQUAL; }
\>\=			{ tokenCount++; return GREATER_OR_EQUAL; }

if		  { tokenCount++; return IF; }
let\*		  { tokenCount++; return LET_STAR; }

\#[tfTF]	  { tokenCount++; return BOOL_LITERAL; }
-?{digit}+	  { tokenCount++; return INT_LITERAL; }

{identifier}      { tokenCount++; return IDENTIFIER; }

"<EOF>"		{ tokenCount++; return END_OF_INPUT; }

.			{ scannerError(); continue; }
